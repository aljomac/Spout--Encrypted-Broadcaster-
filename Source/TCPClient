import java.io.*;
import java.math.BigInteger;
import java.net.*;
import java.lang.System;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.InvalidParameterSpecException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;

import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.Cipher;

import org.apache.commons.codec.binary.Base64;

import javax.crypto.spec.DHParameterSpec;
import javax.crypto.spec.DHPublicKeySpec;
import javax.xml.bind.DatatypeConverter;


public class TCPClient
{
	private static byte[] iv;
	public static TheGUI theGUI;
	private static boolean closeSocket = false;
	private static BufferedReader inFromUser;
	private static DataOutputStream outToServer;
	private static SecretKeySpec privateSymKey;
	private static BufferedReader inFromServer;
	private static String cipherTxtFromServer;
	private static String plainTxtFromServer;
	private static boolean isSrvSet = false;
	private static boolean suspendAll = false;

	//Key Bytes (To be random)

	private static byte[] keyBytes = null;

	
	private static String srvIP;
	private static PublicKey pubKey;
	private static byte[] sharedBytes;
	
	//RSA
	private static BigInteger rsaE;
	private static BigInteger rsaN;
	
	

	/**
	 * ==============================================================
	 * TODO: 
	 * To finish v1.0
	 * 
	 * 
	 * Handle Exceptions
	 * 	- Server goes offline
	 * 	- Client enters wrong IP
	 * 
	 * 
	 * Finish Crypto
	 * 	- Gather private key from GRC
	 * 	- Private key issued by first client.
	 * 	- First client private key becomes the shared secret
	 * 	- Every newly connected client gathers this shared secret with their pubkey
	 * 	- Session expires when all clients disconnect.
	 *
	 *
	 * v2.0 = mobile support, app that can act as client, connect
	 * to same servers however the server can generate QR codes
	 * for mobile shared private key.
	 * ==============================================================
	 */


	public static void main(String argv[]) throws Exception
	{
		//GUI Stuff
		theGUI = new TheGUI();
		
		//Gather Username + server address from client.
		theGUI.getChatDisplay().append("[****]Please input the server address and press enter[****]\n");
		
		//loop to wait for the server ip to be entered.
		while(isSrvSet == false){
			Thread.sleep(1000);
		}
		
		theGUI.setChatDisplay("You are connected to: " + srvIP + "\n" + "\n");
		theGUI.setChatDisplay("This service implements the AES algorithm with ECB chaining and PKCS5Padding." + "\n");
		theGUI.setChatDisplay("So say hi! You don't want to be a rude dude with a bad tude!" + "\n"+ "\n");

		//Get server IP and Create client socket
		InetAddress address = InetAddress.getByName(srvIP);
		Socket clientSocket = new Socket(address, 6874);

		//set I/O
		inFromUser = new BufferedReader(new InputStreamReader(System.in));
		outToServer = new DataOutputStream(clientSocket.getOutputStream());
		inFromServer = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));

		//===============================================
		// 				 RSA KeyPairing.
		//===============================================
		theGUI.getChatDisplay().append("start rsa keypairing" + "\n");
		RSA rsa = new RSA(1024);
		rsa.generateKeys();
		rsaE = rsa.getE();
		rsaN = rsa.getN();


		//===================================
		//		    Send over RSAe
		//===================================
		boolean serverACKe = false;
		boolean serverACKn = false;
		
		theGUI.getChatDisplay().append("sending E" + "\n");
		theGUI.getChatDisplay().append("waiting for server"+"\n");
		
		String check = null;
		String check2 = null;
		while(!serverACKe)
		{
			if(check == null)
				check = inFromServer.readLine();
			

			theGUI.getChatDisplay().append("Check bit: "+check +"\n");
			theGUI.getChatDisplay().append("RSAe: "+rsaE.toString() + "\n");
			
			if(check.equals("1")){
				theGUI.getChatDisplay().append("Received a 1, writing bytes"+"\n");
				outToServer.writeBytes(rsaE.toString() + "\n"); //send the E of rsa public key.
				theGUI.getChatDisplay().append("Wrote rsaE"+"\n");
				
				check2 = inFromServer.readLine();
				theGUI.getChatDisplay().append("This is check 2: "+check2+"\n"+"\n");
			}

			if(check2.equals("0")){
				serverACKe = true;
				theGUI.getChatDisplay().append("Recieved a 0, Server ACK'd the rsaE"+"\n");
			}

		}

		
		//===================================
		//		    Send over RSAn
		//===================================
		String checkn = null;
		String checkn2 = null;
		outToServer.flush();
		
		while(!serverACKn)
		{
			theGUI.getChatDisplay().append("Enter serverACKn"+"\n");
			if(checkn == null)
				checkn = inFromServer.readLine();
			

			theGUI.getChatDisplay().append("Check bit: "+checkn +"\n");
			theGUI.getChatDisplay().append(rsaN.toString() + "\n");
			
			if(checkn.equals("1")){
				theGUI.getChatDisplay().append("Received a 1, writing bytes"+"\n");
				outToServer.writeBytes(rsaN.toString() + "\n"); //send the E of rsa public key.
				theGUI.getChatDisplay().append("Wrote rsaE"+"\n");
				
				checkn2 = inFromServer.readLine();
				theGUI.getChatDisplay().append("This is check 2: "+checkn2+"\n"+"\n");
			}

			if(checkn2.equals("0")){
				serverACKn = true;
				theGUI.getChatDisplay().append("Recieved a 0, Server ACK'd the rsaE"+"\n");
			}
		}
		
		theGUI.getChatDisplay().append("We have Escaped the while loop");

		//==========================================
		//			Exchange the secret.
		//==========================================
		String tempEncrypted = null;
		while(tempEncrypted == null)
		{
			theGUI.getChatDisplay().append("in the keyBytes while." + "\n");
			tempEncrypted = inFromServer.readLine();
			theGUI.getChatDisplay().append("This is key: "+tempEncrypted.toString()+ "\n"+"\n");

			if(tempEncrypted != null)
				outToServer.writeBytes("1" + "\n");

		}
		
		String tempDecrypted = rsa.decrypt(tempEncrypted);//Decrypt the received key with RSA
		theGUI.getChatDisplay().append(tempDecrypted + "\n");
		keyBytes = tempDecrypted.getBytes();//Place bytes into byte[]
		privateSymKey = new SecretKeySpec(keyBytes, "AES"); //create privateSymKey with byte[]
		
		
		//==========================================
		//			Enter the Main loop.
		//==========================================
		theGUI.getChatDisplay().append("enter response loop" + "\n");
		while(true)
		{	
			try {
				cipherTxtFromServer = inFromServer.readLine();
				plainTxtFromServer = Decrypt(cipherTxtFromServer, privateSymKey, iv);
				System.out.println(cipherTxtFromServer);
				SetChatDisplay(plainTxtFromServer);
			} catch (Exception e) {
				theGUI.getChatDisplay().append(e.getMessage());
				e.printStackTrace();
			}

			if(closeSocket)
			{
				clientSocket.close();
				break;
			}
		}
	}


	public static void SendMessage() throws InvalidKeyException, IllegalBlockSizeException,
		BadPaddingException, InvalidAlgorithmParameterException, InvalidParameterSpecException,
			NoSuchAlgorithmException, NoSuchPaddingException, IOException
	{
		String userInput = "";
		String encryptedUserString; 

		//Get Input from GUI
		userInput = theGUI.GetUserInput();

		//Encrypt and send out to socket.
		encryptedUserString = Encrypt(userInput, privateSymKey);
		if(!suspendAll)
			outToServer.writeBytes(encryptedUserString + '\n'); // <-- Dont forget \n for .readLine()
	}

	
	public static void SetChatDisplay(String plainText)
	{
		DateFormat dateFormat = new SimpleDateFormat("HH:mm:ss");
		Calendar cal;
		cal = Calendar.getInstance();
		
		theGUI.getChatDisplay().append("[" + dateFormat.format(cal.getTime()) + "]: " + plainText + '\n');
	}


	private static String Encrypt(String userInput, SecretKeySpec privateSymKey)
	throws IllegalBlockSizeException, BadPaddingException, InvalidKeyException,
		InvalidAlgorithmParameterException, InvalidParameterSpecException,
			NoSuchAlgorithmException, NoSuchPaddingException
	{
		//Initiate cipher class
		Cipher c = Cipher.getInstance("AES/ECB/PKCS5Padding");
		c.init(Cipher.ENCRYPT_MODE, privateSymKey);

		//Encode and encrypt
		String encodedEncryptedString = new String(Base64.encodeBase64String(c.doFinal(userInput.getBytes())));
		return encodedEncryptedString;
	}


	private static String Decrypt(String encryptedUserInput, SecretKeySpec privateSymKey, byte[] theIv)
	throws IllegalBlockSizeException, BadPaddingException, InvalidKeyException,
		InvalidAlgorithmParameterException, UnsupportedEncodingException,
			NoSuchAlgorithmException, NoSuchPaddingException
	{
		//Initiate Cipher
		Cipher c = Cipher.getInstance("AES/ECB/PKCS5Padding");
		c.init(Cipher.DECRYPT_MODE, privateSymKey);

		//decode Result and put it in a byte array
		byte[] decodedEncryptedBytes = Base64.decodeBase64(encryptedUserInput.getBytes());

		//Work Cipher magic
		String decryptedString = new String(c.doFinal(decodedEncryptedBytes), "UTF-8");
		return decryptedString;
	}

	
	public static BigInteger getRsaE(){
		return rsaE;
	}
	
	public static BigInteger getRsaN(){
		return rsaN;
	}

	public static void SetSrvIP(String getUserInput) {
		srvIP = getUserInput;
	}


	public static boolean getIsSrvSet() {
		return isSrvSet;
	}


	public static void setIsSrvSet(boolean value) {
		isSrvSet = value;
	}
	
	public static void setSuspendAll(boolean setter) {
		suspendAll = setter;
	}
	
	public static boolean isSuspendAll()
	{
		return suspendAll;
	}
}
