import java.io.*;
import java.math.BigInteger;
import java.net.*;
import java.lang.System;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidParameterSpecException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;

import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.Cipher;

import org.apache.commons.codec.binary.Base64;


public class TCPClient
{
	private static byte[] iv; //not yet used...	
	public static TheGUI theGUI; //instance of the client GUI
	
	//========================
	//		IO variables
	//========================
	private static boolean closeSocket = false; 
	private static DataOutputStream outToServer;
	private static SecretKeySpec privateSymKey;
	private static BufferedReader inFromServer;
	private static String cipherTxtFromServer;
	private static String plainTxtFromServer;
	private static boolean isSrvSet = false;
	private static boolean suspendAll = false;

	//Key Bytes 
	private static byte[] keyBytes = null;
	private static String srvIP;
	
	//RSA
	private static BigInteger rsaE;
	private static BigInteger rsaN;
	
	

	/**
	 * ==============================================================
	 * TODO: 
	 * To finish v1.0
	 * 
	 * 
	 * Handle Exceptions
	 * 	- Server goes offline
	 * 	- Client enters wrong IP
	 * 
	 *
	 * v2.0 = mobile support, app that can act as client, connect
	 * to same servers however the server can generate QR codes
	 * for mobile shared private key.
	 * ==============================================================
	 */


	public static void main(String argv[]) throws Exception
	{
		//GUI Stuff
		theGUI = new TheGUI();
		
		//Gather Username + server address from client.
		theGUI.getChatDisplay().append("[****]Please input the server address and press enter[****]\n");
		
		//loop to wait for the server ip to be entered.
		while(isSrvSet == false){
			Thread.sleep(1000);
		}
		
		theGUI.setChatDisplay("You are connected to: " + srvIP + "\n" + "\n");
		theGUI.setChatDisplay("This service implements the AES algorithm with ECB chaining and PKCS5Padding." + "\n");
		theGUI.setChatDisplay("So say hi! You don't want to be a rude dude with a bad tude!" + "\n"+ "\n");

		//Get server IP and Create client socket
		InetAddress address = InetAddress.getByName(srvIP);
		Socket clientSocket = new Socket(address, 6874);

		//set I/O
		outToServer = new DataOutputStream(clientSocket.getOutputStream()); //output to server 
		inFromServer = new BufferedReader(new InputStreamReader(clientSocket.getInputStream())); //buffered reader in from server

		//===============================================
		// 				 RSA KeyPairing.
		//===============================================
		theGUI.getChatDisplay().append("start rsa keypairing" + "\n");
		RSA rsa = new RSA(1024); //1024 bit rsa key
		rsa.generateKeys(); //create client side pub/private key paring in RSA
		rsaE = rsa.getE(); //get rsa e value 
		rsaN = rsa.getN(); //get rsa n value


		//===================================
		//		    Send over RSAe
		//===================================
		boolean serverACKe = false;//ack bit for the loop below
		boolean serverACKn = false;//ack bit for the loop below
		
		theGUI.getChatDisplay().append("sending E" + "\n");
		theGUI.getChatDisplay().append("waiting for server"+"\n");
		
		
		/*
		 * So essentially what this loop does is assume we have made a valid connection 
		 * to the server already. A server thread is created for the specific client and 
		 * is by now also in a similar loop in order to receive the clients rsa pubKey.
		 * 
		 * How this works is by a series of ACK's because we only have the I/O pipeline 
		 * established so only way to transfer our key is a stream of bits. So start with 
		 * the server thread sending us an ack bit of 1 until. This one is sent and stored
		 * if "check" and updated with every pass of the while. For every 1, the client 
		 * continues to send its E portion of the public key. This continues until the server
		 * acks with a 0 that it has recieved the E value and then "check2" is set and we then
		 * exit that loop, repeating the same thing for the N portion of the public key.
		 */
		String check = null;
		String check2 = null;
		while(!serverACKe)
		{
			if(check == null)
				check = inFromServer.readLine();
			

			theGUI.getChatDisplay().append("Check bit: "+check +"\n");
			theGUI.getChatDisplay().append("RSAe: "+rsaE.toString() + "\n");
			
			if(check.equals("1")){
				theGUI.getChatDisplay().append("Received a 1, writing bytes"+"\n");
				outToServer.writeBytes(rsaE.toString() + "\n"); //send the E of rsa public key.
				theGUI.getChatDisplay().append("Wrote rsaE"+"\n");
				
				check2 = inFromServer.readLine();
				theGUI.getChatDisplay().append("This is check 2: "+check2+"\n"+"\n");
			}

			if(check2.equals("0")){
				serverACKe = true;
				theGUI.getChatDisplay().append("Recieved a 0, Server ACK'd the rsaE"+"\n");
			}

		}

		
		//===================================
		//		    Send over RSAn
		//===================================
		String checkn = null;
		String checkn2 = null;
		outToServer.flush();
		
		while(!serverACKn)
		{
			theGUI.getChatDisplay().append("Enter serverACKn"+"\n");
			if(checkn == null)
				checkn = inFromServer.readLine();
			

			theGUI.getChatDisplay().append("Check bit: "+checkn +"\n");
			theGUI.getChatDisplay().append(rsaN.toString() + "\n");
			
			if(checkn.equals("1")){
				theGUI.getChatDisplay().append("Received a 1, writing bytes"+"\n");
				outToServer.writeBytes(rsaN.toString() + "\n"); //send the E of rsa public key.
				theGUI.getChatDisplay().append("Wrote rsaE"+"\n");
				
				checkn2 = inFromServer.readLine();
				theGUI.getChatDisplay().append("This is check 2: "+checkn2+"\n"+"\n");
			}

			if(checkn2.equals("0")){
				serverACKn = true;
				theGUI.getChatDisplay().append("Recieved a 0, Server ACK'd the rsaE"+"\n");
			}
		}
		
		theGUI.getChatDisplay().append("We have Escaped the while loop");

		//==========================================
		//			Exchange the secret.
		//==========================================
		/*
		 * In here, we have passed over to our server thread everything it needs to make an instance 
		 * of the clients pubKey. So sit and wait for the server thread to pass along the encrypted 
		 * shared secret, given to it by the server admin [to be changed in the future]. Finish with
		 * ack'ing a 1 back to server.
		 */
		
		String tempEncrypted = null;
		while(tempEncrypted == null)//keep doing it until its not null, only thing that the sever can send is the secret.
		{
			tempEncrypted = inFromServer.readLine();
			theGUI.getChatDisplay().append("This is key: "+tempEncrypted.toString()+ "\n"+"\n");

			if(tempEncrypted != null)
				outToServer.writeBytes("1" + "\n");
		}
		
		String tempDecrypted = rsa.decrypt(tempEncrypted);//Decrypt the received key with RSA
		theGUI.getChatDisplay().append(tempDecrypted + "\n");
		keyBytes = tempDecrypted.getBytes();//Place bytes into byte[]
		privateSymKey = new SecretKeySpec(keyBytes, "AES"); //create privateSymKey with byte[]
		
		
		//==========================================
		//			Enter the Main loop.
		//==========================================
		
		/*
		 * Pretty self explanitory part here. We sit in this loop 99% of the time. Client reads the line,
		 * decrypts the contents then appends them to the GUI.
		 */
		theGUI.getChatDisplay().append("enter response loop" + "\n");
		while(true)
		{	
			try {
				cipherTxtFromServer = inFromServer.readLine();
				plainTxtFromServer = Decrypt(cipherTxtFromServer, privateSymKey, iv);
				System.out.println(cipherTxtFromServer);
				SetChatDisplay(plainTxtFromServer);
			} catch (Exception e) {
				theGUI.getChatDisplay().append(e.getMessage());
				e.printStackTrace();
			}

			if(closeSocket)
			{
				clientSocket.close();
				break;
			}
		}
	}


	/*
	 * This method is used with the GUI. When the user presses enter, the GUI grabs the
	 * text from the userTextField, encrypts the contents and then fires it into the buffer 
	 * reader on the server thread side.
	 */
	public static void SendMessage() throws InvalidKeyException, IllegalBlockSizeException,
		BadPaddingException, InvalidAlgorithmParameterException, InvalidParameterSpecException,
			NoSuchAlgorithmException, NoSuchPaddingException, IOException
	{
		String userInput = "";
		String encryptedUserString; 

		//Get Input from GUI
		userInput = theGUI.GetUserInput();

		//Encrypt and send out to socket.
		encryptedUserString = Encrypt(userInput, privateSymKey);
		if(!suspendAll)
			outToServer.writeBytes(encryptedUserString + '\n'); // <-- Dont forget \n for .readLine()
	}


	/*
	 * sets the chat display in the GUI for a given string
	 */
	public static void SetChatDisplay(String plainText)
	{
		DateFormat dateFormat = new SimpleDateFormat("HH:mm:ss");
		Calendar cal;
		cal = Calendar.getInstance();
		
		theGUI.getChatDisplay().append("[" + dateFormat.format(cal.getTime()) + "]: " + plainText + '\n');
		theGUI.getChatDisplay().setCaretPosition(theGUI.getChatDisplay().getDocument().getLength());
	}


	private static String Encrypt(String userInput, SecretKeySpec privateSymKey)
	throws IllegalBlockSizeException, BadPaddingException, InvalidKeyException,
		InvalidAlgorithmParameterException, InvalidParameterSpecException,
			NoSuchAlgorithmException, NoSuchPaddingException
	{
		//Initiate cipher class
		Cipher c = Cipher.getInstance("AES/ECB/PKCS5Padding");
		c.init(Cipher.ENCRYPT_MODE, privateSymKey);

		//Encode and encrypt
		String encodedEncryptedString = new String(Base64.encodeBase64String(c.doFinal(userInput.getBytes())));
		return encodedEncryptedString;
	}


	private static String Decrypt(String encryptedUserInput, SecretKeySpec privateSymKey, byte[] theIv)
	throws IllegalBlockSizeException, BadPaddingException, InvalidKeyException,
		InvalidAlgorithmParameterException, UnsupportedEncodingException,
			NoSuchAlgorithmException, NoSuchPaddingException
	{
		//Initiate Cipher
		Cipher c = Cipher.getInstance("AES/ECB/PKCS5Padding");
		c.init(Cipher.DECRYPT_MODE, privateSymKey);

		//decode Result and put it in a byte array
		byte[] decodedEncryptedBytes = Base64.decodeBase64(encryptedUserInput.getBytes());

		//Work Cipher magic
		String decryptedString = new String(c.doFinal(decodedEncryptedBytes), "UTF-8");
		return decryptedString;
	}

	
	public static BigInteger getRsaE(){
		return rsaE;
	}
	
	public static BigInteger getRsaN(){
		return rsaN;
	}

	public static void SetSrvIP(String getUserInput) {
		srvIP = getUserInput;
	}


	public static boolean getIsSrvSet() {
		return isSrvSet;
	}


	public static void setIsSrvSet(boolean value) {
		isSrvSet = value;
	}
	
	public static void setSuspendAll(boolean setter) {
		suspendAll = setter;
	}
	
	public static boolean isSuspendAll()
	{
		return suspendAll;
	}
}
