import java.io.*;
import java.math.BigInteger;
import java.net.*;
import java.lang.System;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidParameterSpecException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.regex.Pattern;

import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.Cipher;
import javax.swing.JOptionPane;

import org.apache.commons.codec.binary.Base64;

import com.sun.org.apache.xerces.internal.impl.xs.identity.Selector.Matcher;
import com.sun.webkit.Utilities;


public class TCPClient
{
	private static byte[] iv; //not yet used...	
	public static TheGUI theGUI; //instance of the client GUI
	
	//========================
	//		IO variables
	//========================
	private static DataOutputStream outToServer;
	private static SecretKeySpec privateSymKey;
	private static boolean isSrvSet = false;
	private static boolean suspendAll = false;
	private static String srvIP = null;
	
	
	//=========================
	//		Chat Variables
	//=========================
	private static String userName = null;
	private static boolean isUsernameSet = false;


	//============================
	//	   IP Check variables
	//============================
	private static Pattern VALID_IPV4_PATTERN = null;
	private static Pattern VALID_IPV6_PATTERN = null;
	private static final String ipv4Pattern = "(([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.){3}([01]?\\d\\d?|2[0-4]\\d|25[0-5])";
	private static final String ipv6Pattern = "([0-9a-f]{1,4}:){7}([0-9a-f]){1,4}";

	static {

		VALID_IPV4_PATTERN = Pattern.compile(ipv4Pattern, Pattern.CASE_INSENSITIVE);
		VALID_IPV6_PATTERN = Pattern.compile(ipv6Pattern, Pattern.CASE_INSENSITIVE);
	}
	

	public static void main(String argv[]) throws Exception
	{
		//GUI Stuff
		theGUI = new TheGUI();

		//============================
		//		 Get Username
		//============================
		theGUI.getChatDisplay().append("[***]Please input your desired username...[***]\n");
		while(!isUsernameSet){
			Thread.sleep(1000);
		}
		
		
		//============================
		//		 Get ServerIP
		//============================
		theGUI.getChatDisplay().append("[***]Please input the server address and press enter...[***]\n");
		
		/*
		 * Just loop until a valid IP is entered in terms of string structure.
		 * Then we will look for a timeout exception.
		 */
		Socket clientSocket = null; //Had to start it here or else the code complains.
		while(isSrvSet == false)
		{
			Thread.sleep(1000);

			if(srvIP != null)
			{
				theGUI.getChatDisplay().append("Attempting to connect to: "+"'"+srvIP+"'"+" please wait...\n");
				
				if(!isIpAddress(srvIP))
				{
					JOptionPane.showMessageDialog(theGUI.getPanel(), "The IP address: "+"'"+srvIP+"'"+" is not valid.\n"+"Please try again.","Invalid IP", JOptionPane.ERROR_MESSAGE);
					srvIP = null;
				}

				if(srvIP != null && isIpAddress(srvIP))
				{
					isSrvSet = true;

					//Create client socket
					try {
						clientSocket = new Socket(srvIP, 6874);
					} catch (ConnectException e1) {//catch the timeout exception and restart the process.
						JOptionPane.showMessageDialog(theGUI.getPanel(), "Connection timed out when attempting to connect to: "+"'"+srvIP+"'"+"\n"+"Please try again.","Timed Out", JOptionPane.ERROR_MESSAGE);
						isSrvSet = false;
						srvIP = null;
						e1.printStackTrace();
					}
				}
			}
		}


		//set I/O
		outToServer = new DataOutputStream(clientSocket.getOutputStream()); //output to server 
		BufferedReader inFromServer = new BufferedReader(new InputStreamReader(clientSocket.getInputStream())); //buffered reader in from server


		theGUI.setChatDisplay("You are connected to: " + srvIP + "\n" + "\n");
		theGUI.setChatDisplay("This service implements the AES algorithm with ECB chaining and PKCS5Padding." + "\n"+ "\n");

		
		//waiting for the server to input the shared secret, acks us a 1 when it is finished.
		theGUI.getChatDisplay().append("waiting for server to input secret..."+"\n");
		int aCheck;
		boolean theCheck = false;
		while(!theCheck)
		{
			Thread.sleep(1000);//wait 1 second.
			
			aCheck = inFromServer.read();
			
			if(aCheck == 1)
				theCheck = true;
			
			theGUI.getChatDisplay().append("aCheck: "+aCheck+"\n");
			
		}
		
		outToServer.writeInt(1);//Response to the wait in serverthread.publicKeySwap();
		
		//===============================================
		// 				 RSA KeyPairing.
		//===============================================
		theGUI.getChatDisplay().append("start rsa keypairing" + "\n");
		RSA rsa = new RSA(1024); //1024 bit rsa key
		rsa.generateKeys(); //create client side pub/private key paring in RSA
		BigInteger rsaE = rsa.getE(); //get rsa e value 
		BigInteger rsaN = rsa.getN(); //get rsa n value


		//===================================
		//		    Send over RSAe
		//===================================
		boolean serverACKe = false;//ack bit for the loop below
		boolean serverACKn = false;//ack bit for the loop below
		
		
		/*
		 * So essentially what this loop does is assume we have made a valid connection 
		 * to the server already. A server thread is created for the specific client and 
		 * is by now also in a similar loop in order to receive the clients rsa pubKey.
		 * 
		 * How this works is by a series of ACK's because we only have the I/O pipeline 
		 * established so only way to transfer our key is a stream of bits. So start with 
		 * the server thread sending us an ack bit of 1 until. This one is sent and stored
		 * if "check" and updated with every pass of the while. For every 1, the client 
		 * continues to send its E portion of the public key. This continues until the server
		 * acks with a 0 that it has received the E value and then "check2" is set and we then
		 * exit that loop, repeating the same thing for the N portion of the public key.
		 */
		String check = null;
		String check2 = null;
		while(!serverACKe)
		{
			if(check == null)
				check = inFromServer.readLine();
			

			theGUI.getChatDisplay().append("Check bit: "+check +"\n");
			theGUI.getChatDisplay().append("RSAe: "+rsaE.toString() + "\n");
			
			if(check.equals("1")){
				theGUI.getChatDisplay().append("Received a 1, writing bytes"+"\n");
				outToServer.writeBytes(rsaE.toString() + "\n"); //send the E of rsa public key.
				theGUI.getChatDisplay().append("Wrote rsaE"+"\n");
				
				check2 = inFromServer.readLine();
				theGUI.getChatDisplay().append("This is check 2: "+check2+"\n"+"\n");
			}

			if(check2.equals("0")){
				serverACKe = true;
				theGUI.getChatDisplay().append("Recieved a 0, Server ACK'd the rsaE"+"\n");
			}

		}

		
		//===================================
		//		    Send over RSAn
		//===================================
		String checkn = null;
		String checkn2 = null;
		outToServer.flush();
		
		while(!serverACKn)
		{
			theGUI.getChatDisplay().append("Enter serverACKn"+"\n");
			if(checkn == null)
				checkn = inFromServer.readLine();
			

			theGUI.getChatDisplay().append("Check bit: "+checkn +"\n");
			theGUI.getChatDisplay().append(rsaN.toString() + "\n");
			
			if(checkn.equals("1")){
				theGUI.getChatDisplay().append("Received a 1, writing bytes"+"\n");
				outToServer.writeBytes(rsaN.toString() + "\n"); //send the E of rsa public key.
				theGUI.getChatDisplay().append("Wrote rsaE"+"\n");
				
				checkn2 = inFromServer.readLine();
				theGUI.getChatDisplay().append("This is check 2: "+checkn2+"\n"+"\n");
			}

			if(checkn2.equals("0")){
				serverACKn = true;
				theGUI.getChatDisplay().append("Recieved a 0, Server ACK'd the rsaE"+"\n");
			}
		}
		
		theGUI.getChatDisplay().append("We have Escaped the while loop");

		
		//==========================================
		//			Exchange the secret.
		//==========================================
		/*
		 * In here, we have passed over to our server thread everything it needs to make an instance 
		 * of the clients pubKey. So sit and wait for the server thread to pass along the encrypted 
		 * shared secret, given to it by the server admin [to be changed in the future]. Finish with
		 * ack'ing a 1 back to server.
		 */
		
		String tempEncrypted = null;
		while(tempEncrypted == null)//keep doing it until its not null, only thing that the sever can send is the secret.
		{
			tempEncrypted = inFromServer.readLine();
			theGUI.getChatDisplay().append("This is key: "+tempEncrypted.toString()+ "\n"+"\n");

			if(tempEncrypted != null)
				outToServer.writeBytes("1" + "\n");
		}
		
		String tempDecrypted = rsa.decrypt(tempEncrypted);//Decrypt the received key with RSA
		theGUI.getChatDisplay().append(tempDecrypted + "\n");
		privateSymKey = new SecretKeySpec(tempDecrypted.getBytes(), "AES"); //create privateSymKey with byte[]
		tempDecrypted = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
		
		//==========================================
		//			Enter the Main loop.
		//==========================================
		/*
		 * Pretty self explanitory part here. We sit in this loop 99% of the time. Client reads the line,
		 * decrypts the contents then appends them to the GUI as they come in from the server.
		 */
		boolean closeSocket = false;
		
		theGUI.getChatDisplay().append("enter response loop" + "\n");
		while(true)
		{	
			try {
				String cipherTxtFromServer = inFromServer.readLine();
				String plainTxtFromServer = Decrypt(cipherTxtFromServer, privateSymKey, iv);
				System.out.println(cipherTxtFromServer);
				SetChatDisplay(plainTxtFromServer);
			} catch (javax.crypto.BadPaddingException e) {
				JOptionPane.showMessageDialog(theGUI.getPanel(),"The shared secret you were given: "+" (Hash: "+privateSymKey.hashCode()+")  Does not match that of the other clients connected to "+srvIP+".\nPlease contact your server admin.","Bad Private Key", JOptionPane.ERROR_MESSAGE);
				e.printStackTrace();
			}

			if(closeSocket)
			{
				clientSocket.close();
				break;
			}
		}
	}


	/*
	 * This method is used with the GUI. When the user presses enter, the GUI grabs the
	 * text from the userTextField, encrypts the contents and then fires it into the buffer 
	 * reader on the server thread side.
	 */
	public static void SendMessage() throws InvalidKeyException, IllegalBlockSizeException,
		BadPaddingException, InvalidAlgorithmParameterException, InvalidParameterSpecException,
			NoSuchAlgorithmException, NoSuchPaddingException, IOException
	{
		String userInput = "";
		String encryptedUserString; 

		//Get Input from GUI
		userInput = theGUI.GetUserInput();

		//Encrypt and send out to socket.
		encryptedUserString = Encrypt(" | "+userName+"]: "+userInput, privateSymKey);
		if(!suspendAll)
			outToServer.writeBytes(encryptedUserString + '\n'); // <-- Dont forget \n for .readLine()
	}


	/*
	 * sets the chat display in the GUI for a given string
	 */
	public static void SetChatDisplay(String plainText)
	{
		DateFormat dateFormat = new SimpleDateFormat("HH:mm:ss");
		Calendar cal;
		cal = Calendar.getInstance();
		
		theGUI.getChatDisplay().append("[" + dateFormat.format(cal.getTime()) + plainText + '\n');
		theGUI.getChatDisplay().setCaretPosition(theGUI.getChatDisplay().getDocument().getLength());
	}


	private static String Encrypt(String userInput, SecretKeySpec privateSymKey)
	throws IllegalBlockSizeException, BadPaddingException, InvalidKeyException,
		InvalidAlgorithmParameterException, InvalidParameterSpecException,
			NoSuchAlgorithmException, NoSuchPaddingException
	{
		//Initiate cipher class
		Cipher c = Cipher.getInstance("AES/ECB/PKCS5Padding");
		c.init(Cipher.ENCRYPT_MODE, privateSymKey);

		//Encode and encrypt
		String encodedEncryptedString = new String(Base64.encodeBase64String(c.doFinal(userInput.getBytes())));
		return encodedEncryptedString;
	}


	private static String Decrypt(String encryptedUserInput, SecretKeySpec privateSymKey, byte[] theIv)
			throws IllegalBlockSizeException, BadPaddingException, InvalidKeyException,
			InvalidAlgorithmParameterException, UnsupportedEncodingException,
			NoSuchAlgorithmException, NoSuchPaddingException
	{
		//Initiate Cipher
		Cipher c = Cipher.getInstance("AES/ECB/PKCS5Padding");
		c.init(Cipher.DECRYPT_MODE, privateSymKey);

		//decode Result and put it in a byte array
		byte[] decodedEncryptedBytes = Base64.decodeBase64(encryptedUserInput.getBytes());

		//Work Cipher magic
		String decryptedString = new String(c.doFinal(decodedEncryptedBytes), "UTF-8");
		return decryptedString;
	}

	
	protected static boolean isIpAddress(String ipAddress) 
	{

		java.util.regex.Matcher m1 = VALID_IPV4_PATTERN.matcher(ipAddress);
		if (m1.matches()) {
			return true;
		}
		java.util.regex.Matcher m2 = VALID_IPV6_PATTERN.matcher(ipAddress);
		return m2.matches();
	}


	protected static void SetSrvIP(String getUserInput) {
		srvIP = getUserInput;
	}


	protected static boolean getIsSrvSet() {
		return isSrvSet;
	}


	protected static void setIsSrvSet(boolean value) {
		isSrvSet = value;
	}
	
	protected static void setSuspendAll(boolean setter) {
		suspendAll = setter;
	}
	
	protected static boolean isSuspendAll()
	{
		return suspendAll;
	}


	protected static boolean isUsernameSet() {
		return isUsernameSet;
	}


	protected static void setUsernameSet(boolean isUsernameSet) {
		TCPClient.isUsernameSet = isUsernameSet;
	}
	
	protected static String getUserName() {
		return userName;
	}


	protected static void setUserName(String userName) {
		TCPClient.userName = userName;
	}
}
